Writing Tests for RubyMotion Apps
=================================

이 문서는 이미 있는 RubyMotion앱을 어떻게 단위 테스트하는지에 대해 설명합니다. 테스트는 어플리케이션이 지켜야할 사양의 세트를 제공하며, 불행한 변경으로 인한 회귀(regression)를 잡을때도 사용됩니다.

Getting Started
---------------

RubyMotion에서는 s://github.com/chneukirchen/bacon/[Bacon]을 쓸 수 있습니다. Bacon은 유명한 http://rspec.info/[RSpec] 프레임워크의 축소판 클론으로 https://github.com/chneukirchen[Christian Neukirchen]님이 개발했습니다.

좀더 구체적으로 말하자면, RubyMotion은iOS용으로 확장된 https://github.com/alloy/MacBacon[MacBacon]이라는 버전을 사용하고 있습니다. MacBacon은 https://github.com/alloy[Eloy Duran]님이 관리하고 있습니다.

Spec Files
~~~~~~~~~~

Spec 파일에는 프로젝트의 테스트를 기술해야 합니다.

Spec 파일은 RubyMotion프로젝트의 'spec' 디랙토리의 밑에 작성합니다.

기본설정의 RubyMotion프로젝트는 'spec/main_spec.rb' 파일이 있고, 이 파일에는 어플리케이션이 윈도우를 가지고있는지 확인하는 하나의 테스트가 적혀 있습니다.

Spec Helpers
~~~~~~~~~~~~

Spec helpers 는 클래스나 메소드를 정의해 테스팅 프레임워크를 확장하는데 사용할 수 있습니다. Spec helpers 는 스팩파일보다 먼저 컴파일되고 실행 됩니다.

Spec helpers 는 RubyMotion프로젝트의 'spec/helpers' 디랙토리 밑에 작성합니다. 예를 들면 이런식이죠. 'spec/helpers/extension.rb'

기본설정의 RubyMotion프로젝트는 spec helper를 가지고 있지 않습니다.

Running the Tests
~~~~~~~~~~~~~~~~~

RubyMotion 프로젝트의 테스트 스위트를 실행하기 위해 Rake 테스크의 +spec+을 사용합니다.

----
$ rake spec
$ rake spec:device
----

이 커맨드는 스팩 프래임워크, 헬퍼, 파일이 포함된 스페셜 버전의 앱을 컴파일하고 백그라운드의 시뮬레이터에서 엡을 실행합니다.

일단 spec이 실행 되면, 프로그램은 커맨드라인 프롬프트에 스테이더스 코드(성공일 경우 +0+, 그외에는 +1+)를 돌려줍니다.

Run Selected Spec Files
~~~~~~~~~~~~~~~~~~~~~~~

전체 스팩코드를 실행하는 대신 개별 spec 파일들을 실행하고 싶을때가 있습니다.

실행해야 할 spec 파일을 필터링 하기 위해, 환경변수 +files+에 ","으로 구분된 일련의 패턴을 설정할 수 있습니다. 페턴은 spec 파일의 basename (확장자가 없는 파일명)이거나, 파일경로중 하나여야 합니다.

예를 들어, 밑의 커맨드는 'spec/foo_spec.rb' 와 'spec/bar_spec.rb' 파일만 실행할 것입니다.

----
$ rake spec files=foo_spec,spec/bar_spec.rb
----

Output Format
~~~~~~~~~~~~~

+output+ 환경변수를 지정함으로써 +rake spec+의 출력 포멧을 커스터마이징할 수 있습니다. 가능한 출력 포멧은 +spec_dox+ (디폴트), +fast+, +test_unit+, +tap+, +knock+가 있습니다.

----
$ rake spec output=test_unit
----

Basic Testing
-------------

assertion의 목록이나 프레임워크에서 지원하는 핵심 predicate는 MacBacon의 https://github.com/alloy/MacBacon/blob/master/README.md[README]파일을 참고하십시오.

Views and Controllers Testing
-----------------------------

This layer lets you write functional tests for your controllers and interact with its views through
a set of high-level event generating APIs, by leveraging the functionality of Apple's http://developer.apple.com/library/ios/#documentation/DeveloperTools/Reference/UIAutomationRef/_index.html[UIAutomation] framework without forcing you to write the tests in Javascript.

This consists of a small API available to your specifications, some runloop helpers, and a couple
of `UIView` extensions.

IMPORTANT: This is **not** meant for full application acceptance tests. Therefore you should not let the application launch as normal. This can, for instance, be done by using the +RUBYMOTION_ENV+ to return early from +application:didFinishLaunchingWithOptions:+:

----
class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    return true if RUBYMOTION_ENV == 'test'
    # ...
----

Configuring your Context
~~~~~~~~~~~~~~~~~~~~~~~~

You need to tell the specification context which controller will be specified and extend it with
the required API. You do this by specifying your view controller class in the following way:

----
describe "The 'taking over the world' view" do
  tests TakingOverTheWorldViewController

  # Add your specifications here.
end
----

This will, before each specification, instantiate a new window and a new instance of your view
controller class. These are available in your specifications as `window` and `controller`.

TIP: If you need to perform custom instantiation of either the window or controller then you can
     do so from a `before` filter __before__ calling `tests`.  The same applies to `after` filters.
     If you want those to be able to have a reference to the controller instance used during the
     test, then you will have to register your `after` filter __before__ the `tests` method’s
     `after` filter removes the window and controller instances. For example:

----
describe "Before and after filter order illustrated" do
  # This `before` filter is defined __before__ the one of the `tests` method, so at this point the
  # window instance is not yet created and you can perform controller initialization.  It is
  # important to note, though, that once you call `window` it will be created on-demand.
  before do
    controller.dataThatNeedsToBeConfiguredBeforeAssigningToWindow = ['TableView Row 1', 'TableView Row 2']
  end

  # This `after` filter is defined __before__ the one of the `tests` method, so at this point the
  # window and controller instances are not yet cleaned up and set to `nil`.
  after do
    controller.performCustomPostTestWork
    window.performCustomPostTestWork
  end

  tests TakingOverTheWorldViewController
  # Calling `tests` registers a `before` and an `after` filter that do something like the following:
  #
  #  before do
  #    createWindowAndControllerIfNotCreatedYet
  #  end
  #
  #  after do
  #    cleanUpWindowAndController
  #  end

  it "performs tests" do
    # ...
  end
end
----

Storyboards
^^^^^^^^^^^

You can test controllers from a http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UIStoryboard_Class/Reference/Reference.html[storyboard]
by passing the `tests` method the Xcode identifier of the controller in the `:id` option:

----
tests StoryboardViewController, :id => 'controller-id'
----

By default, controllers will be loaded from the __MainStoryboard.storyboard__ file in the project
__resources__ directory. You can load a controller from a different file by passing the storyboard
name in the `:storyboard` option.

----
tests StoryboardViewController, :storyboard => 'AlternateStoryboard', :id => 'controller-id'
----

TIP: The __Identifier__ field corresponding to the `:id` option is found within the __View Controller__
     section of the __Attributes Inspector__ in Xcode. The __Attributes Inspector__ can be reached with
     the __command-option-4__ keyboard shortcut.

Durations
~~~~~~~~~

Some methods take a `:duration` option which specifies the period of time, in seconds, during which
events will be generated. This is **always** optional.

TIP: The default duration value can be changed through `Bacon::Functional.default_duration=`.

Device Events
~~~~~~~~~~~~~

These methods generate events that operate on the device level. As such, they don’t take an
accessibility label or specific view.

rotate_device
^^^^^^^^^^^^^

Rotates the device to the specified orientation.

----
rotate_device(:to => orientation, :button => location)
----

*     **to**: The orientation to rotate the device to, which can be either `:portrait` or `:landscape`.
* **button**: Used to indicate a specific portrait/landscape orientation which can be either
              `:bottom` or `:top` in portrait mode, or either `:left` or `:right` in landscape
              mode. If omitted, it will default to `:bottom` in portrait mode and `:left` in
              landscape mode.

The following example rotates the device to the landscape orientation with the home button on the
left-hand side of the device:

----
rotate_device :to => :landscape
----

Or to have the button on the right-hand side of the device:

----
rotate_device :to => :landscape, :button => :right
----

accelerate
^^^^^^^^^^

Generates accelerometer events.

----
accelerate(:x => x_axis_acceleration, :y => y_axis_acceleration,
           :z => z_axis_acceleration, :duration => duration)
----

From the http://bit.ly/nWAu5X[UIAcceleration class reference]:

* **x**: With the device held in portrait orientation and the screen facing you, the x axis runs
         from left (negative values) to right (positive values) across the face of the device.
* **y**: With the device held in portrait orientation and the screen facing you, the y axis runs
         from bottom (negative values) to top (positive values) across the face of the device.
* **z**: With the device held in portrait orientation and the screen facing you, the z axis runs
         from back (negative values) to front (positive values) through the device.

This will simulate a device laying still on its back:

----
accelerate :x => 0, :y => 0, :z => -1
----

shake
^^^^^

Essentially generates accelerometer events.

----
shake()
----

Use this when you want to specifically trigger a shake motion event.

For more information see the http://bit.ly/MV57Y9[event handling guide].

Finding Views
~~~~~~~~~~~~~

These methods allow you to retrieve views. They traverse down through the view hierarchy, starting
from the current `window`.

If no view matches, then they will keep re-trying it during the `timeout`, which defaults to three
seconds. This means you don’t need to worry about whether or not the view you’re looking for is
still being loaded or animated.

Finally, if the timeout passes and **no** view matches an exception will be raised.

TIP: The default timeout value can be changed through `Bacon::Functional.default_timeout=`.

view
^^^^

Returns the view that matches the specified accessibility label.

----
view(label)
----

Example:

----
button = UIButton.buttonWithType(UIButtonTypeRoundedRect)
button.setTitle('Take over the world', forState:UIControlStateNormal)
window.addSubview(button)

view('Take over the world') # => button
----

TIP: See `UIView#viewByName(accessibilityLabel, timeout)`.

views
^^^^^

Returns an array of all the views that match the given class.

----
views(view_class)
----

Example:

----
button1 = UIButton.buttonWithType(UIButtonTypeRoundedRect)
button1.setTitle('Take over the world', forState:UIControlStateNormal)
window.addSubview(button1)

button2 = UIButton.buttonWithType(UIButtonTypeRoundedRect)
button2.setTitle('But not tonight', forState:UIControlStateNormal)
window.addSubview(button2)

views(UIButton) # => [button1, button2]
----

TIP: See `UIView#viewsByClass(viewClass, timeout)`.

View Events
~~~~~~~~~~~

These methods all operate on views. You specify the view to operate on by its ‘accessibility label’
or pass in a view instance.

NOTE: In general all the UIKit controls will have decent default values for their accessibility
      labels. E.g. a UIButton with title “Take over the world” will have the same value for its
      accessibility label. If, however, you have custom views, or otherwise need to override the
      default, then you can do so by setting its `accessibilityLabel` attribute.

Wherever a ‘location’ is required you can either specify a `CGPoint` instance or use one of the
following constants:

* `:top_left`
* `:top`
* `:top_right`
* `:right`
* `:bottom_right`
* `:bottom`
* `:bottom_left`
* `:left`

NOTE: `CGPoint` instances have to be specified in window coordinates.

TIP: Some of the methods take a `:from` location and a `:to` location option. If __only__ `:from`
     or `:to` is specified and __with__ a location constant, then the other option can be omitted
     and will default to the opposite of the specified location. If, however, a `CGPoint` instance
     is used, then the other option __has__ to be specified as well.

tap
^^^

Generates events that simulate tapping a view.

----
tap(label_or_view, :at => location, :times => number_of_taps, :touches => number_of_fingers)
----

All of these options are optional:

*      **at**: The location where the tap will occur. Defaults to the center of the view.
*   **times**: The number of times to tap the view. Defaults to a single tap.
* **touches**: The number of fingers used to tap the view. Defaults to a single touch.

Tapping a view __once__ only requires:

----
button = UIButton.buttonWithType(UIButtonTypeRoundedRect)
button.setTitle('Take over the world', forState:UIControlStateNormal)
window.addSubview(button)

tap 'Take over the world'
----

Tapping a view twice with two fingers requires you to specify those options:

----
view = UIView.alloc.initWithFrame(CGRectMake(0, 0, 100, 100))
view.accessibilityLabel = 'tappable view'
recognizer = UITapGestureRecognizer.alloc.initWithTarget(self, action:'handleTap:')
recognizer.numberOfTapsRequired = 2
recognizer.numberOfTouchesRequired = 2
view.addGestureRecognizer(recognizer)

tap 'tappable view', :times => 2, :touches => 2
----

flick
^^^^^

Generates a short fast drag gesture.

----
flick(label_or_view, :from => location, :to => location, :duration => duration)
----

* **from**: The location where the drag will start.
*   **to**: The location where the drag will end.

Flicking a switch would be done like so:

----
switch = UISwitch.alloc.initWithFrame(CGRectMake(0, 0, 100, 100))
switch.accessibilityLabel = 'Enable rainbow theme'
window.addSubview(switch)

flick 'Enable rainbow theme', :to => :right
----

pinch_open
^^^^^^^^^^

Generates an __opening__ pinch gesture.

----
pinch_open(label_or_view, :from => location, :to => location, :duration => duration)
----

* **from**: The location where __both__ fingers are at the start of the gesture. Defaults to
            `:left`.
*   **to**: The location where the __moving__ finger will be at the end of the gesture. Defaults to
            `:right`.

The following zooms in on the content view of a `UIScrollView`:

----
view('Zooming scrollview').zoomScale # => 1.0
pinch_open 'Zooming scrollview'
view('Zooming scrollview').zoomScale # => 2.0
----

pinch_close
^^^^^^^^^^^

Generates a __closing__ pinch gesture.

----
pinch_close(label_or_view, :from => location, :to => location, :duration => duration)
----

* **from**: The location where the __moving__ finger will be at the start of the gesture. Defaults
            to `:right`.
*   **to**: The location where __both__ fingers are at the end of the gesture. Defaults to `:left`.

The following zooms out of the content view of a `UIScrollView`:

----
view('Zooming scrollview').zoomScale # => 1.0
pinch_close 'Zooming scrollview'
view('Zooming scrollview').zoomScale # => 0.5
----

drag
^^^^

Generates a drag gesture (i.e. panning, scrolling) over a path interpolated between the start and
end location.

----
drag(label_or_view, :from => location, :to => location, :number_of_points => steps,
     :points => path, :touches => number_of_fingers, :duration => duration)
----

*             **from**: The location where the drag will start. Not used if `:points` is specified.
*               **to**: The location where the drag will end. Not used if `:points` is specified.
* **number_of_points**: The number of points along the path that is interpolated between `:from`
                        and `:to`. Defaults to 20. Not used if `:points` is specified.
*           **points**: An array of `CGPoint` instances that specify the drag path.
*          **touches**: The number of fingers used to drag. Defaults to a single touch.

NOTE: Keep in mind that **scrolling** into a direction means **dragging** into the __opposite__
      direction.

The following will scroll down in a scroll view:

----
view('Scrollable scrollview').contentOffset.y # => 0
drag 'Scrollable scrollview', :from => :bottom
view('Scrollable scrollview').contentOffset.y # => 400
----

rotate
^^^^^^

Generates a clockwise rotation gesture around the center point of the view.

----
rotate(label_or_view, :radians => angle, :degrees => angle, :touches => number_of_fingers,
       :duration => duration)
----

* **radians**: The angle of the rotation in radians. Defaults to π.
* **degrees**: The angle of the rotation in degrees. Defaults to 180.
* **touches**: The number of fingers used to rotate. Defaults to 2.
